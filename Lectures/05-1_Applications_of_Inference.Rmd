---
title: "Applications of Inference Frameworks"
subtitle: "Quantitative Methods in Life Sciences"
author: 'Elizabeth King and Kevin Middleton'
date: 'Last updated: `r Sys.Date()`'
output:
  xaringan::moon_reader:
    seal: yes
    nature:
      highlightStyle: github
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(rstan)
library(cowplot)
library(plot3D)
#library(rgl)
#setupKnitr <- function() {
#  if (requireNamespace("knitr")) {
#    knitr::knit_hooks$set(webgl = hook_webgl)
#    knitr::knit_hooks$set(rgl = hook_rgl)
#    environment(hook_webgl)$commonParts <- TRUE
#    environment(hook_webgl)$reuse <- TRUE
#  }
#}
```

# Notes

## Readings
- Curran-Everett [-@curran-everett_explorations_2009]: Explorations in statistics: confidence intervals


## Three frameworks for inference

1. Analytical
2. Maximum likelihood
3. Bayesian

## Inferring a mean

Mean undulation rate for $n = 8$ gliding snakes (http://www.flyingsnake.org/):

```{r}
undulation_rate <- c(0.9, 1.2, 1.2, 1.3, 1.4, 1.4, 1.6, 2.0)
```

![](http://www.lazerhorse.org/wp-content/uploads/2015/01/Flying-Snake-Chrysopelea.jpg)

What is the mean undulation rate for this sample of flying snakes?

---

```{r undulation_plot, message=FALSE}
ggplot(data_frame(undulation_rate), aes(undulation_rate)) +
  geom_histogram() +
  labs(x = "Undulation Rate (Hz)", y = "Count")
```

## Analytical inference of mean

Arithmetic mean:

$$\hat{Y} = \frac{\sum_{i=1}^{n}Y_i}{n}$$

$$mean~undulation~rate = \frac{\sum_{i=1}^{n}undulation~rate_i}{n}$$

## Analytical inference of mean

```{r}
sum(undulation_rate) / length(undulation_rate)
```

## Maximum likelihood inference of mean

Define a function to calculate the probability of an observed value $Y_i$ drawn from a [normal distribution](http://mathworld.wolfram.com/NormalDistribution.html) given the mean ($\mu$) and standard deviation ($\sigma$). Default to the [standard normal distribution](http://mathworld.wolfram.com/StandardNormalDistribution.html) $\mathcal{N}(0,1)$.

$$f\left(Y_i; \mu, \sigma\right) = \frac{1}{\sqrt{2\pi\sigma^{2}}} e^{\frac{-\left(Y_i-\mu\right)^{2}}{2\sigma^{2}}}$$

```{r}
normal <- function(Y, mu = 0, sigma = 1) {
  1 / sqrt(2 * pi * sigma ^ 2) * 
    exp((-(Y - mu) ^ 2 / (2 * sigma ^ 2)))
}
```

_Note_: this function is built into R as `dnorm()`.

## Test our function

```{r}
normal(0, mu = 0, sigma = 1)
dnorm(0, mean = 0, sd = 1)
```

```{r normal_plot, echo=FALSE, fig.height=2.5}
M <- data_frame(x = seq(-3, 3, length = 100),
                y = dnorm(x))
ggplot(M, aes(x, y)) + geom_line() +
  labs(x = "Y", y = "Probability")
```

## Calculating a likelihood

If the true mean is 0 and the standard deviation is 1, what is the likelihood of the observed values?

1. This is a model.
2. Calculate the probability of each observation.
3. Overall model likelihood is the product of the individual probabilities.
4. log-likelihood is more tractable, so calculate that.

## Model Likelihood ($\mathcal{L}$)

For a set of $Y_i$ and parameters ($\Theta$; i.e., mean and standard deviation) the likelihood of the model is the product of their individual probabilities:

$$\mathcal{L}\left(\left\{ Y_{i}\right\} _{i=1}^{n};\Theta\right) = \prod_{i=1}^{n}\phi\left(Y_{i}; \Theta\right)$$

Evaluate the likelihood function for different values of $\Theta$ to estimate $\mathcal{L}$ for different sets of $\Theta$.

- Maximize $\mathcal{L}$ and you will have the maximum likelihood set of parameter estimates.

## Model Likelihood ($\mathcal{L}$)

Probabilities are in the range 0 to 1, so taking the product of a large number of probabilities can result in some very small numbers.

- Computers don't handle really small numbers very well
    - There is a lower limit to the smallest number a computer can keep track of.
    - This is $`r .Machine$double.xmin`$ in R on the computer that compiled these slides.

Think about computing the likelihood for thousands or millions of observations.

```{r}
.50^1000
```

## Model Likelihood ($\mathcal{L}$)

It's usually easier to minimize the (natural) log of the likelihood function. The log-likelihood is easier to deal with mathematically.

$$\mathcal{L}\left(\left\{ Y_{i}\right\} _{i=1}^{n};\Theta\right) = \prod_{i=1}^{n}\phi\left(Y_{i}; \Theta\right)$$

Log both sides of the equation:

$$\log\left(\mathcal{L}\left(\left\{ Y_{i}\right\} _{i=1}^{n};\Theta\right)\right) = \log\left(\prod_{i=1}^{n}\phi\left(Y_{i};\Theta\right)\right)$$

## Model Likelihood ($\mathcal{L}$)

Taking advantage of the algebraic rules associated with logs (the log of the products equals the sum of the logs):

$$\log\left(\mathcal{L}\left(\left\{ Y_{i}\right\} _{i=1}^{n};\Theta\right)\right) = \sum_{i=1}^{n} \log\left(\phi\left(Y_{i};\Theta\right)\right)$$

So we just need to sum the log-likelihoods to get the overall model likelihood. 

_Note_: `log()` is _natural_ log.

## Calculating the log-likelihood for a single combination of $\mu$ and $\sigma$

If the mean is 0 and the standard deviation is 1, what is the likelihood of the observed values?

Probability for the first observation (`undulation_rate[1]`):

```{r}
undulation_rate[1]
normal(undulation_rate[1], mu = 0, sigma = 1)
```

---

```{r, echo=FALSE, fig.height=4.5}
ggplot(M, aes(x, y)) + geom_line() +
  labs(x = "Y", y = "Probability") +
  geom_point(aes(x = undulation_rate[1],
                 y = normal(undulation_rate[1], mu = 0, sigma = 1)),
             color = "red",
             size = 3) +
  geom_segment(aes(x = undulation_rate[1],
                   xend = undulation_rate[1],
                   y = 0,
                   yend = normal(undulation_rate[1],
                                 mu = 0, sigma = 1)),
               color = "red")
```

This is only the probability for first observation. We need the likelihoods for all `r length(undulation_rate)` undulation rates to get a model likelihood.

## Calculating the log-likelihood for a single combination of $\mu$ and $\sigma$

Vector of probabilities for all values in `undulation_rate` given `mu = 0` and `sigma = 1`:

```{r}
(probs <- normal(undulation_rate, mu = 0, sigma = 1))
```

Overall likelihood is the product of those probabilities:

```{r}
(lik <- prod(probs))
```

## Likelihood to log-likelihood

```{r}
log(lik)
sum(log(probs))
```

If the true mean is 0 and true standard deviation is 1, then the model log-likelihood is `r round(log(lik), 3)`.

Is there another combination of $\mu$ and $\sigma$ that gives a higher likelihood (= larger log-likelihood)?

```{r}
sum(log(normal(undulation_rate, mu = 1, sigma = 1)))
```

## Calculating the log-likelihood for a _range_ of $\mu$ and $\sigma$

Find the combination of $\mu$ and $\sigma$ that maximizes the log-likelihood of the model for the mean and standard deviation of undulation rates.

Ranges of possible values:

1. Mean ($\mu$): $-\infty < \mu < \infty$
2. Standard deviation ($\sigma$): $0 < \sigma < \infty$

## Grid approximation

For combinations of $\mu$ and $\sigma$, calculate the model likelihood. Pick the largest log-likelihood as the maximum likelihood estimates.

Set up the grid:

```{r}
n <- 100
mus <- seq(0.1, 5, length = n)
sigmas <- seq(0.1, 2, length = n)

grid_mu_sigma <- mesh(mus, sigmas)

grid_approx <- data_frame(
  mu = as.numeric(grid_mu_sigma$x),
  sigma = as.numeric(grid_mu_sigma$y),
  log_lik = rep(NA, length = n ^ 2)
)
```

---

```{r}
grid_approx
```

## Grid approximation

```{r grid_approx, cache=TRUE}
for (i in 1:nrow(grid_approx)) {
  grid_approx[i, 3] <- 
    sum(log(normal(undulation_rate,
                   mu = grid_approx$mu[i],
                   sigma = grid_approx$sigma[i])))
}
head(grid_approx)
```

This approach is coarse and time consuming. For $n = `r n`$, there are `r nrow(grid_approx)` comparisons.

## Grid approximation

```{r echo=FALSE}
grid_approx <- do.call(data.frame,
                       lapply(grid_approx,
                              function(x) replace(x, is.infinite(x), NA)))
scatter3D(grid_approx$mu, grid_approx$sigma, grid_approx$log_lik, pch = 16,
          labels = c("mu", "sigma", "log-likelihood"))
```

## Grid approximation

On this grid, the maximum likelihood estimates of $\mu$ and $\sigma$ are:

```{r}
grid_approx[which.max(grid_approx$log_lik), ]
```

## Maximum likelihood as an optimization problem

```{r echo=FALSE}
scatter3D(grid_approx$mu, grid_approx$sigma, grid_approx$log_lik, pch = 16,
          labels = c("mu", "sigma", "log-likelihood"), colkey = FALSE)
```

## Maximum likelihood as an optimization problem

Define a function that takes a vector of values to optimize `x` ($\mu$ and $\sigma$) as well as a set of data `Y` and returns the log-likelihood:

```{r}
log_lik <- function(x, Y){
  probs <- normal(Y, mu = x[1], sigma = x[2])
  return(sum(log(probs)))
}
```

We can now jointly optimize $\mu$ and $\sigma$, maximizing the log-likelihood.

## Maximum likelihood as an optimization problem

```{r ML_optim, cache = TRUE}
optim(c(0.1, 0.1), # Start at 0.1, 0.1
      log_lik,
      Y = undulation_rate,
      control = list(fnscale = -1,
                     reltol = 10^-100))
```

## Maximum likelihood as an optimization problem

```{r ML_glm}
fm <- glm(undulation_rate ~ 1)
coef(fm)
logLik(fm)
```

## Bayesian inference of mean

Ranges of possible maximum likelihood values:

1. $\mu$: $-\infty < \mu < \infty$
2. $\sigma$: $0 < \sigma < \infty$

Drawbacks:

1. $\mu$ can't be negative (no negative undulation rates) and probably isn't a large number
2. $\sigma$ is also probably not huge either

Can we do better? Yes, Bayesian priors.

## Prior for the mean

```{r, ref.label="undulation_plot", echo=FALSE, message=FALSE}

```

## Prior for the mean

Cauchy distribution (location = 0, scale = 2)

```{r echo=FALSE, fig.height=3.5}
data_frame(
  x = seq(0, 10, length = 100),
  y = dcauchy(x, scale = 2)) %>% 
  ggplot(aes(x, y)) + geom_line() +
  labs(y = "Probability", x = "value")
```

## Bayesian model

[stan](http://mc-stan.org/) code:

```{r}
model <- "
  data{
    int<lower=1> N;
    real undulation_rate[N];
  }
  parameters{
    real<lower=0> mu;
    real<lower=0> sigma;
  }
  model{
    sigma ~ cauchy(0, 5);
    mu ~ cauchy(0, 2);
    undulation_rate ~ normal(mu, sigma);
  }
"
```

## Sample the Bayesian model

```{r stan_fit, cache=TRUE}
fm_priors <- stan(
  model_code = model,
  data = list(undulation_rate = undulation_rate,
              N = length(undulation_rate)),
  iter = 10^4,
  warmup = 10^3,
  seed = 12)
```

## Inspecting the samples

```{r echo=FALSE}
traceplot(fm_priors)
```

## Summarizing the results

```{r, echo=FALSE}
post <- extract(fm_priors) %>% as_data_frame()
post %>% gather(key, value) %>% 
  filter(key != "lp__") %>% 
  ggplot(aes(value)) +
  geom_line(stat = "density") +
  facet_grid(. ~ key) +
  labs(x = "Value", y = "Density")
```

## Summarizing the results

```{r echo=FALSE}
print(fm_priors, digits = 3)
```

We get a lower mean than the analytical or ML estimate (`r round(mean(undulation_rate), 3)`) because the prior places more probability on lower values.
