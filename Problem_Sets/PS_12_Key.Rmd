---
title: 'Problem Set 12'
author: "Your Name Here: Group X"
date: 'Last updated: `r Sys.Date()`'
output:
  html_document:
    smart: no
    theme: flatly
    toc: true
    toc_float: true
---

```{r setup, message=FALSE, warning=FALSE}
library(tidyverse)
library(readxl)
library(cowplot)
library(ape)
library(nlme)
library(MCMCglmm)

# This option turn on cacheing of chunks. This will dramatically
# speed up knitting, because only chunks that have changed will
# be recompiled.
knitr::opts_chunk$set(cache = TRUE)
```


## Sole

In lecture, we looked at presence/absence data for the common sole ([*Solea solea*](https://en.wikipedia.org/wiki/Common_sole)) predicted by the salinity of the water. That data set has a great deal of additional information. In this question, we will explore the predictors of sole being found in the estuary.

### Activity

Load the sole data from the file `Sole.xlsx`. Several of the variables are categorical and should be converted into factors: season, month, area, and Solea_solea. Go ahead and do this now. As a final step, convert your object with the data into a `data.frame` with `as.data.frame()`.

```{r}
# FIXME
M <- read_excel("../data/Sole.xlsx")
M <- M %>% mutate(season = factor(season),
                  month = factor(month),
                  area = factor(area),
                  Solea_solea = factor(Solea_solea))
M <- M %>% as.data.frame()
str(M)
```

Season and area are going to be of particular interest in these data. Check the number of observations (i.e., count the rows) for each combination of season and area. Ensure that there are observations for all combinations.

```{r}
# FIXME
M %>% group_by(season, area) %>% tally()
```

If all goes well, you should find 6-12 observations for each season/area combination. That isn't really a lot, but probably enough for this example. Let's determine if there is a seasonality in the appearance of sole in the estuary.

Fit a generalized linear model where the presence of sole is modeled by the additive effects of season and area. This formula will look much like an `lm()` model, except that it will call `glm()` and include `family "binomial"` to indicate the R should use the logit link function.

```{r}
# FIXME
fm <- glm(Solea_solea ~ season + area, data = M,
          family = "binomial")
```

Generate an ANOVA table with the `Anova()` function using type III sums of squares for your fitted model. This process is similar to what you would use for a regular linear model.

```{r}
# FIXME
Anova(fm, type = "III")
```

Which of season, area, or both are good predictors of the presence of sole? What is your interpretation of these results? Which of the two is more variable?

> Only area is a good predictor (P = 0.0001).

Use the `logistic.display()` function from the `epiDisplay` package to generate the odds ratio table for the model. You will likely have to install the package.

```{r}
# FIXME
logistic.display(fm)
```

See if you can make sense of the odds ratios in the context of the ANOVA table. Try to explain what it tells you.

> Adjusted odds ratio for season isn't significant (i.e., after setting area to 0), with a CI that crosses 1. Each area is compared to area 1, and all are significantly different from one another. It seems reasonable to conclude that there is considerable variation in the presence/absence of sole among the four areas. This is actullay bad, because area to area variation is higher than seasonal variation. There appears to be substantial geographic heterogeneity in sole presence.


## Testing a new drug

We will use data on the effects of a drug on fever, blood pressure, and pain. There are two treatments here: the drug, and a placebo as a control. We want to ask if the drug affects fever, blood pressure, or pain and conversely whether we can predict drug treatment from the change in symptoms.

### Activity

First read in the data (`Drug_test.xlsx`) and make `Treatment` a factor. You will need to make "Placebo" as the base level of the factor.

```{r}
M <- read_excel("../data/Drug_test.xlsx") %>%
  mutate(Treatment = factor(Treatment),
         Treatment = fct_relevel(Treatment, "Placebo"))
str(M)
```

Use `ggscatmat()` to visualize the relationships between our predictors: `Fever`, `BP`, and `Pain`. Color your points by treatment.

```{r}
ggscatmat(M, 1:3, color = "Treatment")
```

Are there any concerning patterns in the data?

> No, looks fine.

Fit a generalized linear model using `glm()`, predicting `Treatment` from `Fever`, `BP`, and `Pain`. Specify `family` as binomial to perform a logistic regression.

Use 1) `summary()`, 2) `logisitic.display()` from the `epiDisplay` package, and 3) `Anova()`, specifying type III sums of squares to look at the results. What can you conclude?

> Only fever is a good predictor of whether a person received the drug vs. placebo. The adjusted odds ratio of 0.23 (0.09 - 0.63) suggests that those with lower levels of fever were more likely to have received the drug. You can observe this in the scatterplot matrix in the upper left panel.

```{r}
# FIXME
fm <- glm(Treatment ~ Fever + BP + Pain, data = M,
          family = "binomial")

summary(fm)
logistic.display(fm)
Anova(fm, type = "III")
```

########################################################

Packages that you will need for this problem set that you might not have installed yet:

- `ape`
- `MCMCglmm`

Go ahead and install them now. Also load the `nlme` package, which has the `gls()` function.



## Indian meal moth

For this activity, we will use a dataset measuring the amount of phenoloxidase (PO) produced by indian meal moth caterpillars in full-sibling families. 

### Activity

First we will load the `MCMCglmm` library and get the moth data called `PlodiaPO`.

```{r}
library(MCMCglmm)
data(PlodiaPO)
```

Examine the data. Look at the first few rows and use `unique()` to see the list of families in this dataset. Plot a histogram of the PO values and calculate the overall mean value.


```{r}
head(PlodiaPO)
unique(PlodiaPO$FSfamily)

ggplot(PlodiaPO, aes(x = PO)) +
  geom_histogram()

mean(PlodiaPO$PO)
```

Now we will fit the MCMCglmm model with family as a random effect.

```{r}
fm <- MCMCglmm(PO ~ 1,
               random = ~ FSfamily,
               data = PlodiaPO,
               verbose = TRUE)
```

Refer to the lecture slides for the next section. Plot the fixed effects and calculate the median for the estimate of the intercept. Compare this value to the mean value you calculated above. 

```{r}
plot(fm$Sol)

mean(PlodiaPO$PO)
median(fm$Sol)
```

Now plot the random effects and calculate heritability for all the MCMC samples. Because we have fit family here instead of using an animal model like in lecture, you should multiply your estimate by 2. This is because full-sib families share 50% of their genes on average. Plot the resulting distribution of heritability estimates. Estimate the median value and the standard error. 

```{r}
plot(fm$VCV)

h2 <- 2 * fm$VCV[, "FSfamily"]/(fm$VCV[, "FSfamily"] + fm$VCV[, "units"])

plot(h2)

median(h2)
sd(h2)
```

## Primate life history

We are going to work with two files, one containing a tree of (extant) primates (226 tips; `Primate_Masses_Tree.nex`) and another containing data of primate life history (`Primate_Masses.xlsx`). We will use these data to explore phylogenetic comparative methods.

### Activity

Load the `Primate_Masses.xlsx` file and explore the contents. You will find columns:

- `Order`: Traditional Linnean order
- `Family`: Traditional Linnean family
- `Binomial`: Genus species binomial. *This column matches the tree tip labels.*
- `AdultBodyMass_g`: Body mass in grams
- `GestationLen_d`: Gestation length in days
- `HomeRange_km2`: Home range area in square kilometers
- `MaxLongevity_m`: Maximum longevity in months
- `SocialGroupSize`: Mean social group size

As a final step, be sure to convert the object into a `data.frame` from the `tibble` that `read_excel()` produces by default.

```{r}
# FIXME
M <- read_excel("../data/Primate_Masses.xlsx") %>% as.data.frame()
```

Load the tree from the file `Primate_Masses_Tree.nex` using the function `read.nexus()` which is in the `ape` package.

Give it is useful name like `tree`. Plot the tree using the `plot()` method for `phylo` objects (which is what your tree will be). In the `plot()` call, include you can make the tip labels smaller with `cex = 0.8`. We expanded the figure size in the chunk header to keep the tips from overlapping. It will look like a mess in the RStudio window, but will look OK when knitted.

```{r, fig.height=30, fig.width=10}
# FIXME
tree <- read.nexus("../data/Primate_Masses_Tree.nex")
plot(tree, cex = 0.8)
```

Any time you have comparative data and a tree, you should do a lot of tests to make sure that the tree labels match the data column that codes for them. 
Some functions will do these checks for you. However, it's important to do these checks yourself, just to be sure. They are absolutely necessary when you are using phylogenetically independent contrasts or another method that makes assumptions about a match between tips and data without an explicit check. Using `gls()` for PGLS will do this also, albeit with a warning message.

Start by looking at both the `Binomial` column of your data frame and the tip labels of the tree (e.g., `tree$tip.label`).

```{r}
# FIXME
M$Binomial
tree$tip.label
```

Let's figure out what tree tips are not represented in the data file (a lot probably) and what data are not represented in the tree (hopefully only a few). Let's start by looking at the species that are present in both the data and the tree. We use the intersection of the `Binomial` column and the tip labels (the function `intersect()`). Change `eval` to true in the following chunk.

```{r eval=TRUE}
# FIXME
intersect(tree$tip.label, M$Binomial)
```

How many species are present in both? How many rows of data are there? How many tips or taxa need to be dropped in total (we don't know yet which are tips are which are taxa)?

> 83 are present in both. There are 91 data observations, so 8 must not match up.

The first step in the process is to keep only the tips of the tree where tips are present in the data. The `setdiff()` function returns a vector of the differences between two sets. If we use the same syntax as above but with `setdiff` rather than `intersect`, we'll get the list of tips that need to be dropped. Create that variable and call it something memorable like `tips_to_drop`. There should be 143 tips in the list.

```{r}
tips_to_drop <- setdiff(tree$tip.label, M$Binomial)
length(tips_to_drop)
```

Now we can actually drop the tips from the tree. The `ape` package has a function `drop.tip()` which does just this. Create a new tree (e.g., `tree_pruned`) where all the orphan tips are dropped. Look at the help for `drop.tip()` for the syntax. Then plot your tree to make sure it still looks OK. We we use this tree for the rest of this exercise.

```{r, fig.height=15, fig.width=10}
# FIXME
tree_pruned <- drop.tip(tree, tips_to_drop)
plot(tree_pruned)
```

We should probably also remove any rows from the data that are not present in the tree. This isn't strictly necessary in most cases, but it's good practice. We can use `setdiff()` again, but this time reverse the order: `setdiff(M$Binomial, tree_pruned$tip.label)`. Do this, and save to a new variable `rows_to_drop`. You should find 8 rows that need to be dropped from the data frame.

```{r}
# FIXME
rows_to_drop <- setdiff(M$Binomial, tree_pruned$tip.label)
length(rows_to_drop)
```

 Drop the rows from the data that are not in the tree. The best (though least clear) way to do this is with a notation like `M[!(M$Binomial %in% rows_to_drop), ]`. The `!` negates the entire parenthetical that follows. Inside parentheses, the function `%in%` returns true for all the rows in `M$Binomial` that match any items in `rows_to_drop`. So by negating this set, we get all the rows that are *not* in `rows_to_drop`.

Assign a new variable the data frame resulting from dropping all rows not in the tree file. Check the number of rows. You should find 83.

```{r}
# FIXME
M_pruned <- M[!(M$Binomial %in% rows_to_drop), ]
nrow(M_pruned)
```

The final thing to do is to assign `Binomial` to the row names (`row.names()`) of the data.frame.

```{r}
# FIXME
row.names(M_pruned) <- M_pruned$Binomial
```

We have finally arrived at the point of being able to do something with these data. As you may have realized, working with comparative data is much more involved in terms of processing than working with regular data.

For the rest of this question, we will be exploring the relationship between body mass and maximum longevity. Make a scatterplot of the raw data for maximum longevity vs. body mass.

```{r}
# FIXME
ggplot(M_pruned, aes(x = AdultBodyMass_g, y = MaxLongevity_m)) +
  geom_point()
```

Assess the bivariate relationship and transform either or both of the variables if they require it.

```{r}
# FIXME
M_pruned$log_Mass <- log10(M_pruned$AdultBodyMass_g)
M_pruned$log_Longevity <- log10(M_pruned$MaxLongevity_m)
ggplot(M_pruned, aes(x = log_Mass, y = log_Longevity, color = Family)) +
  geom_point()
```

> We can log10 transform both variables. It's probably adequate to only log mass, but it looks a little better with both transformed.

We're ready to perform PGLS. Fit a PGLS using `gls()` regressing longevity on mass. Use a Brownian motion correlation structure. Follow the lecture slides as an example. Save this model to an R object. Print the summary of the `gls` object that you just made.

```{r}
# FIXME
fm1 <- gls(log_Longevity ~ log_Mass, data = M_pruned,
           correlation = corBrownian(phy = tree_pruned),
           method = "ML")
summary(fm1)
```

e. What is the linear equation for the phylogenetic regression of longevity on body mass?

> log Longevity = 2.07 + 0.11 * log Mass. 

Fit a second model where `Family` is used in addition to mass. Use an additive model and Brownian motion model of trait evolution. Use the `anova()` method to generate an ANOVA table for the model fit.

```{r}
fm2 <- gls(log_Longevity ~ log_Mass + Family, data = M_pruned,
           correlation = corBrownian(phy = tree_pruned),
           method = "ML")
summary(fm2)
anova(fm2)
```

Considering the ANOVA table, does the relationship between longevity and mass differ by family? Briefly explain.

> No. The *P*-value for family is 0.999, so there is no difference in the relationship based on family. The intercepts are all equal to one another.

Extract (`AIC()`) and compare the AICs for the two models you just fit. Interpret the difference in AIC values.

```{r}
AIC(fm1, fm2)
```

> The difference is 25 AIC units, with the simpler model *much* preferred.

Feel free to explore other variables in this data set.


## Aspirin and cancer

The file `Aspirin.csv` contains data on the frequency of cancer in 39,876 women taking or not taking low-dose aspirin.^[Cook, N.R., I. Lee, J.M. Gaziano, D. Gordon, P.M. Ridker, J.E. Manson, C.H. Hennekens, and J.E. Buring. 2005. Low-dose aspirin in the primary prevention of cancer. _Journal of the American Medical Association_ 294: 47-55.]

The authors were interested in determining whether the odds of cancer differed in women, depending on whether they regularly took a low dose of aspirin.

### Activity

Read in the data, and convert all the variables to factors. Look at the help for `mutate_each()` for a shortcut.

```{r message = FALSE}
M <- read_csv("../data/Aspirin.csv") %>%
  mutate_each("factor")
str(M)
```

Tally up the number of obvervations in each group.

```{r}
M %>% group_by(Treatment, Cancer) %>% tally()
```

Another way to look at the same information is using a cross tabulation, also called a contingency table. The R function `xtabs()` takes a one sided formula and returns the count in each group. Your code will look something like `xtabs(~ Treatment + Cancer, M)`.

```{r}
#FIXME
xtabs(~ Treatment + Cancer, M)
```

The usual way to analyze data consisting of counts is to use a $\chi^2$ test. In R, `chisq.test()` is the function that carries out this test. One of the nice things about `chisq.test()` is that you can pass it the object returned by `xtabs()`.

Run a $\chi^2$ test on the cross tabulation of the aspirin data. Use the `correct = FALSE` argument to *not* use Yates's correction.

```{r}
chisq.test(xtabs(~ Treatment + Cancer, M),
           correct = FALSE)
```

What is your interpretation of the $\chi^2$ test?

> P = 0.82, so there is no association between treatment and cancer.

Because the outcome variable, `Cancer`, is binomially distributed, we could also use a logistic regression to analyze these data.

Fit a logistic regression where presence of cancer is predicted by treatment. Save the result to an object.

```{r}
fm <- glm(Cancer ~ Treatment, M, family = "binomial")
```

Analyze the model you fit using ANOVA with type III sums of squares and using `logistic.display()`.

```{r}
Anova(fm, type = "III")
logistic.display(fm)
```

From these results, what can you conclude about a $\chi^2$ test and logistic regression in this case?

> They are equivalent in this situation.
